# Design proposals for 2020 architecture

## Current key design questions
- receivedCheck: composite index school uuid/pupil uuid only allows one check to be stored
- restart: could require an existing receivedCheck to be overwritten / invalidated
  - insertOrUpdate rather than insertOrMerge as we want any prior validation/marking data to be removed
- restart: must invalidate existing allocated check
- restart: store on existing check, but indicate pupil is allowed restart (update pupil flags)
- checkConfig: move data and functionality to dedicated microservice/function?
- checkNotifier: mtc_admin columns to support processing errors

## Next steps

### Analysis day 27th Aug 2019
- Establish 'pupil state' design.
  - Add columns to pupil table?
  - have separate pupil state table?
  - eliminate pupil status function and infer state from pupil state
- Restarts
  - attach to pupil table directly
  - pupil restart table serves as a log/audit trail
  - bind to check on creation?
  - create check as part of restart procedure?
  - invalidate entire restart & check at end of day if not used?
  - is this OK with UX/business?

### Pupil Journey Meeting Friday 13th September 2019
- pupil logged on still required - not a status anymore
- when validation fails, notify teacher
  - sent from validation service to the check-notifier
- when marking fails, inform teacher
  - sent from marking service to the check-notifier

### Tech session Monday 16th September 2019
- checkConfig.  move to table storage?
- it is currently the authority on a checks used config
- what is the composite index? pupil uuid/check code

## Pupil API
consider converting to function.
input trigger would be http
2nd input binding would be table storage with filter to get message automatically
### why?
- less moving parts, part of a function app
- no docker/server to maintain
### why not?
- extra dev work
- aint broke, don't fix it
- serves on average at 130ms~

## pupil prefs
http function as a service for GET/POST/DELETE.
has its own dedicated data store, preferably redis or table storage.
pupil-spa would need credential challenge
### dependencies
- admin app (get/set prefs)
- pupil spa (set prefs)
- pupil api (get prefs)
### why?
- isolates data and functionality (true microservice)
- moves demand away from SQL
### why not?
- extra dev work
- ain't broke, don't fix it
- harder to report on
- breaks existing functionality

## pupil-login function
- existing function updates check table directly with logged in time
- existing submits pupil-status update message to queue
### changes
- create table storage 'pupilLogin'
  - partitionKey: pupilUUID
  - rowKey: checkCode
- remove pupil-status queue
- do not update sql

Should not influence pupil status, but should serve as a support element to acknowledge when pupil logged in.
illustrates the issue of combining the pupils current status with check status.

## check notifier function & queue
triggered by message on check-notification service bus queue.
responsible for updating mtc_admin.check with submission progress.
- check received
- check 'complete'
- check processing failures
  - sql.mtc_admin.check.receivedByServerAt is updated to current UTC datetime
    - if update fails or check is not found this information is recorded in sqlUpdateError column of receivedCheck record
    - the execution timeout of the function must take into consideration the potential for waits on the storage operations

## check-validator function & queue

triggered by a new message on the check-validation service bus queue.
Hydrates and validates an entry in the receivedCheck table.
uses complete-check schema to validate check has same top level properties
Records 'validatedAt' in UTC against the entry on completion.
Submits a check-marking message onto the queue after recording validation datetime.
Records a 'validationError' against the entry on failure.
submits 'check-notification' message to indidate validation failure (shares same 'processing failure' outcome with check-marking function)

### check-validation queue properties (currently service bus)
- Max size: 1GB (to be reviewed)
- TTL: 14 days
- Lock duration: 5 minutes
- Duplicate detection: enabled
- Duplicate detection window: 1 day
- Dead lettering on expiration: true
- Sessions/FIFO: false
- Partitioning: false

## check marker function & queue

triggered by a new message on the check-marking service bus queue.
Hydrates and marks an entry in the receivedCheck table.
records 'mark' against the entry on completion.
submits 'check-notification' message to indidate success/failure of marking (shares same 'processing failure' outcome with check-validator function)
Further actions to be defined, but will include signalling that check is ready for PS report and MI.

### check-marking queue properties
- Max size: 1GB (to be reviewed)
- TTL: 14 days
- Lock duration: 5 minutes
- Duplicate detection: enabled
- Duplicate detection window: 1 day
- Dead lettering on expiration: true
- Sessions/FIFO: false
- Partitioning: false

## check-started function

To be retired
implement version construct as per other functions
Q: restarts depend on a check-started being received - is this brittle? Yes, restarts no longer depend on this.
Q: how could we record check-started in a non status related way? separate db / microservice?

### storage options for received checks

Preference is to store the message as-is in an immutable state. CheckCode and SchoolUUID will be top level properties to use as composite key.
Compressed 'large' complete check is ~24KB

#### Table Storage (classic)
- max property length of 32KB
- high performance
- low cost
- partition and row key fit well with school ID & check code

#### Cosmos SQL API
- Key/Value JSON store
- supports function bindings
- cost: TBC
- scale: TBC
- 'basic' container has a 10GB storage capacity and throughput of 400 request units per second, costing $0.033 USD per hour.
- supports multiple indexes
- üëéüèº hard upper limit based on configured scale

#### BLOB Storage
- container per school, named by school UUID
- check persisted as `{checkCode}.json`
- cheap
- üëéüèº no function bindings
- üëéüèº complicated pricing (storage size, I/O rates, storage term)
 - üëéüèº 'dumb' container / no query functionality other than school UUID & checkCode

#### SQL Server
- managing schema / migrations
- effectively stores JSON as a blob
- üëéüèº potentially expensive
- üëéüèº no function bindings
- üëéüèº hard upper limit based on configured scale


### revised journey

- check receiver function:
  - message is received from the complete-check queue
  - properties are validated against v2 schema
  - message is decompressed to reveal JSON payload
  - school UUID is extracted to provide partition key
  - checkCode is extracted to provide row key
  - record is inserted into receivedCheck table
    - partition key: schoolUUID
    - record primary key: checkCode / pupilUUID
    - checkData: compressed archive property value
    - dateReceived: current UTC datetime
  - sql.mtc_admin.check.receivedByServerAt is updated to current UTC datetime
    - if update fails or check is not found this information is recorded in sqlUpdateError column of receivedCheck record
    - the execution timeout of the function must take into consideration the potential for waits on the storage operations
- check validator function:
  - insertion of entry into receivedCheck triggers input binding
  - properties of JSON payload are checked to ensure schema is correct
  - message is dispatched to unmarked-check queue via output binding
- check marker function:
  - message is received from unmarked-check queue
  - properties are validated against V1 schema (schoolid and checkCode)
  - receivedCheck entry is retrieved
  - check is marked
  - score is recorded in mark column
  - row is updated in receivedCheck table
  - if marking fails, error details are stored in markError column and row is updated
